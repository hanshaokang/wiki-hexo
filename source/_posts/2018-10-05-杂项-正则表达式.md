---
title: 正则表达式
toc: true
date: 2018-10-05 09:06:13
tags:
  - 正则表达式
categories:
  - 杂项
  - 正则表达式
---

正则表达式其实并没有想像中的那么困难，但是想要熟练的掌握它，还是需要下功夫勤加练习的。

## 正则表达式到底是什么东西？

正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

用于文件查找的 &#42; 和 ? 叫做通配符。如果你想查找某个目录下的所有的 Word 文档的话，你会搜索 &#42;.doc。在这里，&#42; 会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以 0 开头，后面跟着 2-3 个数字，然后是一个连字号 “-”，最后是 7 或 8 位数字的字符串 (像 010-12345678 或 0321-7654321)。

## 元字符

|元字符|解释|
| :--: | :--|
| `\` | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。 |
| `^` | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |
| `$` | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |
| `*` | 匹配前面的子表达式零次或多次。例如，zo&#42; 能匹配 "z" 以及 "zoo"。&#42; 等价于{0,}。 |
| `+` | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| `?` | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。 |
| `{n}` | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| `{n,}` | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o&#42;'。 |
| `{n,m}` | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |
| `?` | 当该字符紧跟在任何一个其他限制符 (&#42;, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 |
| `.` | 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.&#124;\n)"的模式。 |
| `(pattern)` | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 |
| `(?:pattern)` | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (&#124;) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y&#124;ies) 就是一个比 'industry&#124;industries' 更简略的表达式。 |
| `(?=pattern)` | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95&#124;98&#124;NT&#124;2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| `(?!pattern)` | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95&#124;98&#124;NT&#124;2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| `(?<=pattern)` | 向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?<=95&#124;98&#124;NT&#124;2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。 |
| `(?<!pattern)` | 向否定预查，与正向否定预查类似，只是方向相反。例如"(?<`!`95&#124;98&#124;NT&#124;2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。 |
| `x&#124;y` | 匹配 x 或 y。例如，'z&#124;food' 能匹配 "z" 或 "food"。'(z&#124;f)ood' 则匹配 "zood" 或 "food"。 |
| `[xyz]` | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。 |
| `[^xyz]` | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。 |
| `[a-z]` | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |
| `[^a-z]` | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |
| `\b` | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| `\B` | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| `\cx` | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\d` | 匹配一个数字字符。等价于 [0-9]。 |
| `\D` | 匹配一个非数字字符。等价于 [^0-9]。 |
| `\f` | 匹配一个换页符。等价于 \x0c 和 \cL。 |
| `\n` | 匹配一个换行符。等价于 \x0a 和 \cJ。 |
| `\r` | 匹配一个回车符。等价于 \x0d 和 \cM。 |
| `\s` | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| `\S` | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 |
| `\t` | 匹配一个制表符。等价于 \x09 和 \cI。 |
| `\v` | 匹配一个垂直制表符。等价于 \x0b 和 \cK。 |
| `\w` | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。 |
| `\W` | 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。 |
| `\xn` | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
| `\num` | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |
| `\n` | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| `\nm` | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| `\nml` | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| `\un` | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |

## 字符分类及语法

### **普通字符**
  普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

### **非打印字符**
  非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：
  | 字符 | 描述 |
  |:---:|:---|
  | `\cx` | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或   a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
  | `\f` | 匹配一个换页符。等价于 \x0c 和 \cL。 |
  | `\n` | 匹配一个换行符。等价于 \x0a 和 \cJ。 |
  | `\r` | 匹配一个回车符。等价于 \x0d 和 \cM。 |
  | `\s` | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
  | `\S` | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 |
  | `\t` | 匹配一个制表符。等价于 \x09 和 \cI。 |
  | `\v` | 匹配一个垂直制表符。等价于 \x0b 和 \cK。 |

### **特殊字符**
  所谓特殊字符，就是一些有特殊含义的字符，许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：
  | 特别字符 | 描述 |
  |:---:|:---|
  | `$` | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。|
  | `( )` | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。|
  | `*` | 匹配前面的子表达式零次或多次。要匹配 &#42; 字符，请使用 \\*。|
  | `+` | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。|
  | `.` | 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。|
  | `[` | 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。|
  | `?` | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。|
  | `\` | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\\\' 匹配 "\\"，而 '\\(' 则匹配 "("。|
  | `^` | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。|
  | `{` | 标记限定符表达式的开始。要匹配 {，请使用 \\{。|
  | &#124; | 指明两项之间的一个选择。要匹配 &#124;，请使用 \\&#124;。|

### **限定符**
  限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。&#42;、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。正则表达式的限定符有：
  | 字符 | 描述|
  |:---:|:---|
  | `&#42;` | 匹配前面的子表达式零次或多次。例如，zo&#42; 能匹配 "z" 以及 "zoo"。&#42; 等价于{0,}。|
  | `+` | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。|
  | `?` | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。|
  | `{n}` | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。|
  | `{n,}` | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o&#42;'。|
  | `{n,m}` | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。|
  
### **定位符**
  定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。
  定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。
  正则表达式的定位符有：
  | 字符 | 描述 |
  |:---:|:---|
  | `^` | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 |
  | `$` | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 |
  | `\b` | 匹配一个单词边界，即字与空格间的位置。 |
  | `\B` | 非单词边界匹配。 |

### **选择与反向引用**

- **选择**
  用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。
  其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

- **反向引用**
  对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。

## 运算符优先级

相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

| 运算符 | 描述 |
|:---:|:---|
| `\` | 转义符 |
| `()`, `(?:)`, `(?=)`, `[]` | 圆括号和方括号 |
| `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` | 限定符 |
| `^`, `$`, `\任何元字符、任何字符` | 定位点和序列（即：位置和顺序） |
| `|` | 替换，"或"操作字符具有高于替换运算符的优先级，使得"m&#124;food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m&#124;f)ood"。 |

## 匹配规则

### **基本模式匹配**

### **字符簇**
```
[a-z] //匹配所有的小写字母 
[A-Z] //匹配所有的大写字母 
[a-zA-Z] //匹配所有的字母 
[0-9] //匹配所有的数字 
[0-9\.\-] //匹配所有的数字，句号和减号 
[ \f\r\t\n] //匹配所有的白字符
```
PHP的正则表达式有一些内置的通用字符簇，列表如下：

| 字符簇 | 描述 |
|:---:|:---|
| `[[:alpha:]]` | 任何字母 |
| `[[:digit:]]` | 任何数字 |
| `[[:alnum:]]` | 任何字母和数字 |
| `[[:space:]]` | 任何空白字符 |
| `[[:upper:]]` | 任何大写字母 |
| `[[:lower:]]` | 任何小写字母 |
| `[[:punct:]]` | 任何标点符号 |
| `[[:xdigit:]]` | 任何16进制的数字，相当于[0-9a-fA-F] |

### **重复出现**

可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。
|字符簇 | 描述 |
|:---:|:---|
| `^[a-zA-Z_]$ ` | 所有的字母和下划线 |
| `^[[:alpha:]]{3}$ ` | 所有的3个字母的单词 |
| `^a$ ` | 字母a |
| `^a{4}$ ` | aaaa |
| `^a{2,4}$ ` | aa,aaa或aaaa |
| `^a{1,3}$ ` | a,aa或aaa |
| `^a{2,}$ ` | 包含多于两个a的字符串 |
| `^a{2,} ` | 如：aardvark和aaab，但apple不行 |
| `a{2,} ` | 如：baad和aaa，但Nantucket不行 |
| `\t{2} ` | 两个制表符 |
| `.{2} ` | 所有的两个字符 |

## 一些不被普遍支持的内容

### **零宽断言**https://www.cnblogs.com/yunfeifei/p/4071467.html

正则表达式的先行断言和后行断言一共有4种形式： 
- (?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion) 
- (?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion) 
- (?<=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion) 
- (?<!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion) 

这里面的pattern是一个正则表达式。

如同^代表开头，$代表结尾，\b代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为“零宽”。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。 
下面分别举例来说明这4种断言的含义。

- (?=pattern) 正向先行断言 
代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。 
例如对”a regular expression”这个字符串，要想匹配regular中的re，但不能匹配expression中的re，可以用”re(?=gular)”，该表达式限定了re右边的位置，这个位置之后是gular，但并不消耗gular这些字符，将表达式改为”re(?=gular).”，将会匹配reg，元字符.匹配了g，括号这一砣匹配了e和g之间的位置。

- (?!pattern) 负向先行断言 
代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。 
例如对”regex represents regular expression”这个字符串，要想匹配除regex和regular之外的re，可以用”re(?!g)”，该表达式限定了re右边的位置，这个位置后面不是字符g。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。

- (?<=pattern) 正向后行断言 
代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。 
例如对”regex represents regular expression”这个字符串，有4个单词，要想匹配单词内部的re，但不匹配单词开头的re，可以用”(?<=\w)re”，单词内部的re，在re前面应该是一个单词字符。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。

- (?<!pattern) 负向后行断言 
代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。 
例如对”regex represents regular expression”这个字符串，要想匹配单词开头的re，可以用”(?<!\w)re”。单词开头的re，在本例中，也就是指不在单词内部的re，即re前面不是单词字符。当然也可以用”\bre”来匹配。


对于这4个断言的理解，可以从两个方面入手：
1. 关于先行(lookahead)和后行(lookbehind)：正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。 
2. 关于正向(positive)和负向(negative)：正向就表示匹配括号中的表达式，负向表示不匹配。


对这4个断言形式的记忆： 
1. 先行和后行：后行断言(?<=pattern)、(?<!pattern)中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。 
2. 正向和负向：不等于(!=)、逻辑非(!)都是用!号来表示，所以有!号的形式表示不匹配、负向；将!号换成=号，就表示匹配、正向。


我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个字符或某些字符也很容易，用[^...]形式就可以了。要表示一个字符串中不包含某个子串（由字符序列构成）呢？ 
用[^...]这种形式就不行了，这时就要用到（负向）先行断言或后行断言、或同时使用。 
例如判断一句话中包含this，但不包含that。 
包含this比较好办，一句话中不包含that，可以认为这句话中每个字符的前面都不是that或每个字符的后面都不是that。正则表达式如下： 
^((?<!that).)&#42;this((?<!that).)&#42;\$ 或 ^(.(?!that))&#42;this(.(?!that))&#42;\$ 
对于”this is the case”这句话，两个表达式都能够匹配成功，而”note that this is the case”都匹配失败。
在一般情况下，这两个表达式基本上都能够满足要求了。考虑极端情况，如一句话以that开头、以that结尾、that和this连在一起时，上述表达式就可能不胜任了。 
如”note thatthis is the case”或者”this is the case, not that”等。 
只要灵活运用这几个断言，就很容易解决： 
^(.(?<!that))&#42;this(.(?<!that))&#42;\$ 
^(.(?<!that))&#42;this((?!that).)&#42;\$ 
^((?!that).)&#42;this(.(?<!that))&#42;\$ 
^((?!that).)&#42;this((?!that).)&#42;\$ 
这4个正则表达式测试上述的几句话，结果都能够满足要求。

上述4种断言，括号里的pattern本身是一个正则表达式。但对2种后行断言有所限制，在Perl和Python中，这个表达式必须是定长(fixed length)的，即不能使用&#42;、+、?等元字符，如(?<=abc)没有问题，但(?<=a×bc)是不被支持的，特别是当表达式中含有|连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java支持?、{m}、{n,m}等符号，但同样不支持&#42;、+字符。Javascript干脆不支持后行断言，不过一般来说，这不是太大的问题。

## 参考资料
> - [菜鸟教程-正则表达式](http://www.runoob.com/regexp/regexp-tutorial.html)
> - [雲霏霏-有shi以来最详细的正则表达式入门教程](https://www.cnblogs.com/yunfeifei/p/4071467.html)

